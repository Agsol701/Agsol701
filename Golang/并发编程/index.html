



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
        <meta name="author" content="Agsol">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>并发编程 - Agsol的技术栈</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.adb8469c.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#golang" tabindex="0" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="Agsol的技术栈" aria-label="Agsol的技术栈" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Agsol的技术栈
            </span>
            <span class="md-header-nav__topic">
              
                并发编程
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="Agsol的技术栈" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Agsol的技术栈
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Python
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Python
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="计算机基础" class="md-nav__link">
      计算机基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="基本数据类型" class="md-nav__link">
      基本数据类型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/" title="常量与变量" class="md-nav__link">
      常量与变量
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/" title="数值类型" class="md-nav__link">
      数值类型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/" title="基本运算符" class="md-nav__link">
      基本运算符
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串" class="md-nav__link">
      字符串
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%88%97%E8%A1%A8/" title="列表" class="md-nav__link">
      列表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%AD%97%E5%85%B8/" title="字典" class="md-nav__link">
      字典
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E9%9B%86%E5%90%88/" title="集合" class="md-nav__link">
      集合
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/bytesbytearray/" title="bytesbytearray" class="md-nav__link">
      bytesbytearray
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="流程控制" class="md-nav__link">
      流程控制
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%87%BD%E6%95%B0/" title="函数" class="md-nav__link">
      函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/" title="内建函数" class="md-nav__link">
      内建函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/" title="递归函数" class="md-nav__link">
      递归函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/" title="文件处理" class="md-nav__link">
      文件处理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" title="字符编码" class="md-nav__link">
      字符编码
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%9B%9B%E5%BC%8F%E5%9B%9B%E5%99%A8/" title="四式四器" class="md-nav__link">
      四式四器
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E7%B1%BB/" title="类" class="md-nav__link">
      类
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象" class="md-nav__link">
      面向对象
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E6%A8%A1%E5%9D%97/" title="模块" class="md-nav__link">
      模块
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" title="进程和线程" class="md-nav__link">
      进程和线程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/Python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/" title="Python中的进程" class="md-nav__link">
      Python中的进程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/Python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/" title="Python中的线程" class="md-nav__link">
      Python中的线程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" title="线程同步" class="md-nav__link">
      线程同步
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Python/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="异常处理" class="md-nav__link">
      异常处理
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Golang
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Golang
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../golang%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/" title="golang简介及安装" class="md-nav__link">
      golang简介及安装
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/" title="变量和常量" class="md-nav__link">
      变量和常量
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="标识符及数据类型" class="md-nav__link">
      标识符及数据类型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/" title="数字类型" class="md-nav__link">
      数字类型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/" title="布尔类型" class="md-nav__link">
      布尔类型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/" title="字符类型" class="md-nav__link">
      字符类型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E8%BF%90%E7%AE%97%E7%AC%A6/" title="运算符" class="md-nav__link">
      运算符
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%8C%85/" title="包" class="md-nav__link">
      包
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串" class="md-nav__link">
      字符串
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%87%BD%E6%95%B0/" title="函数" class="md-nav__link">
      函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="流程控制" class="md-nav__link">
      流程控制
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%95%B0%E7%BB%84/" title="数组" class="md-nav__link">
      数组
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E5%88%87%E7%89%87/" title="切片" class="md-nav__link">
      切片
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../map/" title="map" class="md-nav__link">
      map
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%8C%87%E9%92%88/" title="指针" class="md-nav__link">
      指针
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E7%BB%93%E6%9E%84%E4%BD%93/" title="结构体" class="md-nav__link">
      结构体
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95/" title="结构体的方法" class="md-nav__link">
      结构体的方法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5/" title="结构体的匿名字段" class="md-nav__link">
      结构体的匿名字段
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../%E6%8E%A5%E5%8F%A3/" title="接口" class="md-nav__link">
      接口
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Django
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Django
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Django/django%E5%89%8D%E8%A8%80/" title="django前言" class="md-nav__link">
      django前言
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Django/django%E5%9F%BA%E7%A1%80%E4%B8%89%E6%9D%BF%E6%96%A7/" title="django基础三板斧" class="md-nav__link">
      django基础三板斧
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Django/django%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/" title="django静态文件" class="md-nav__link">
      django静态文件
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Django/django%E8%BF%9E%E6%8E%A5MySQL/" title="django连接MySQL" class="md-nav__link">
      django连接MySQL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Django/MTV%E4%B8%8EMVC%E6%A8%A1%E5%9E%8B/" title="MTV与MVC模型" class="md-nav__link">
      MTV与MVC模型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Django/django%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%B1%82/" title="django之路由层" class="md-nav__link">
      django之路由层
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      网络编程
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        网络编程
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程" class="md-nav__link">
      网络编程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="网络模型" class="md-nav__link">
      网络模型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Dns%E8%AF%A6%E8%A7%A3/" title="Dns详解" class="md-nav__link">
      Dns详解
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/http%E5%8D%8F%E8%AE%AE/" title="http协议" class="md-nav__link">
      http协议
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    全局变量互斥锁
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sync" class="md-nav__link">
    sync包
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <div class="toc">
<ul>
<li><a href="#golang">Golang中的并发编程</a><ul>
<li><a href="#_1">全局变量互斥锁</a></li>
<li><a href="#sync">sync包</a></li>
</ul>
</li>
<li><a href="#goroutine">goroutine</a><ul>
<li><a href="#_2">使用</a></li>
<li><a href="#goroutine_1">启动单个goroutine</a></li>
<li><a href="#goroutine_2">启动多个goroutine</a></li>
<li><a href="#_3">可增长的栈</a></li>
<li><a href="#goroutine_3">goroutine调度</a></li>
<li><a href="#gomaxprocs">GOMAXPROCS</a></li>
</ul>
</li>
<li><a href="#channel">channel</a><ul>
<li><a href="#_4">声明</a><ul>
<li><a href="#_5">说明</a></li>
</ul>
</li>
<li><a href="#_6">初始化</a></li>
<li><a href="#_7">操作</a><ul>
<li><a href="#_8">发送</a></li>
<li><a href="#_9">接收</a></li>
<li><a href="#_10">关闭</a></li>
<li><a href="#_11">注意:</a></li>
</ul>
</li>
<li><a href="#_12">无缓冲的通道</a><ul>
<li><a href="#_13">注意</a></li>
</ul>
</li>
<li><a href="#_14">有缓冲的管道</a></li>
<li><a href="#channel_1">接收空接口的channel</a></li>
<li><a href="#channel_2">channel的遍历</a></li>
<li><a href="#_15">单向通道</a></li>
<li><a href="#channel_3">channel的阻塞机制</a></li>
<li><a href="#_16">通道异常总结</a></li>
<li><a href="#_17">异常捕获</a></li>
</ul>
</li>
<li><a href="#worker-poolgoroutine">worker pool(goroutine池)</a><ul>
<li><a href="#select">select多路复用</a></li>
</ul>
</li>
<li><a href="#_18">并发安全和锁</a><ul>
<li><a href="#_19">互斥锁</a></li>
<li><a href="#_20">读写互斥锁</a></li>
<li><a href="#syncwaitgroup">sync.WaitGroup</a><ul>
<li><a href="#_21">并发安全的单例模式</a></li>
</ul>
</li>
<li><a href="#syncmap">sync.Map</a></li>
</ul>
</li>
<li><a href="#_22">原子操作</a><ul>
<li><a href="#atomic">atomic包</a><ul>
<li><a href="#_23">示例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="golang">Golang中的并发编程<a class="headerlink" href="#golang" title="Permanent link">&para;</a></h1>
<p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡**通过通信共享内存**而不是**通过共享内存而实现通信**。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h3 id="_1">全局变量互斥锁<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="c1">//编写一额函数,计算1到200各个数的阶乘,并放入map种</span>
<span class="c1">//启动多个协程,将统计的结果放到map,此map应该是一个全局的</span>
<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">myMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">//计算n的阶乘,将结果放入map中</span>
<span class="kd">func</span> <span class="nx">test</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">res</span> <span class="o">*=</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="c1">//将res结果放入myMap中</span>
    <span class="nx">myMap</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>  
    <span class="c1">//会触发fatal error: concurrent map writes错误</span>
    <span class="c1">//触发了写保护</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//开启多个协程完成任务</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">200</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">test</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
    <span class="c1">//输出map结果</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">myMap</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;map[%d]=%d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//go build -race main.go  当出现资源竞争的时候,race会将信息打印出来</span>
<span class="c1">//会报Found 3 data race(s),表示三个资源竞争</span>
</code></pre></div>

<p>使用goroutine时,会出现并发/并行安全问题.</p>
<p>可以通过加入互斥锁来解决问题.</p>
<h3 id="sync">sync包<a class="headerlink" href="#sync" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;sync&quot;</span>
<span class="p">)</span>

<span class="c1">//编写一额函数,计算1到200各个数的阶乘,并放入map种</span>
<span class="c1">//启动多个协程,将统计的结果放到map,此map应该是一个全局的</span>
<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">myMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="c1">//声明一个全局的互斥锁</span>
    <span class="c1">//lock 是一个全局的互斥锁,</span>
    <span class="c1">//synv synchornized同步包</span>
    <span class="c1">//Mutex互斥,排他,是一个结构体,其中有Lock和Unlock两个方法</span>
    <span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">)</span>

<span class="c1">//计算n的阶乘,将结果放入map中</span>
<span class="kd">func</span> <span class="nx">test</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">res</span> <span class="o">*=</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="c1">//将res结果放入myMap中</span>
    <span class="c1">//加锁</span>
    <span class="nx">lock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">myMap</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
    <span class="c1">//解锁</span>
    <span class="nx">lock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="c1">//会触发fatal error: concurrent map writes错误</span>
    <span class="c1">//触发了写保护</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//开启多个协程完成任务</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">test</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// time.Sleep(time.Second * 10)</span>
    <span class="c1">//输出map结果</span>
    <span class="nx">lock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">myMap</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;map[%d]=%d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">lock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//go build -race main.go  当出现资源竞争的时候,race会将信息打印出来</span>
<span class="c1">//会报Found 3 data race(s),表示三个资源竞争</span>
</code></pre></div>

<p>结果不会报错</p>
<h1 id="goroutine">goroutine<a class="headerlink" href="#goroutine" title="Permanent link">&para;</a></h1>
<p>Go语言中的goroutine概念类似线程,但是goroutine是由Go的运行时(runtime)调度和管理的.Go程序会智能的将goroutine中的任务合理的分配给每个CPU.</p>
<h3 id="_2">使用<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>只需要在调用函数的时候在前面加上go关键字,就可与为一个函数创建一个goroutine.</p>
<p>一个goroutine必须对应一个函数,可以创建多个goroutine去执行相同的函数.</p>
<h3 id="goroutine_1">启动单个goroutine<a class="headerlink" href="#goroutine_1" title="Permanent link">&para;</a></h3>
<p>只需要在调用的函数(普通函数或匿名函数)前面加一个go关键字</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">hello</span><span class="p">(){</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="k">go</span> <span class="nx">hello</span><span class="p">()</span><span class="c1">// 启动另外一个goroutine去执行hello函数</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;main done&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>程序启动时,Go程序会为main()函数创建一个默认的goroutine.</p>
<p>当main()函数返回的时候该goroutine就结束了,main()函数中所有启动的goroutine都会一并结束.</p>
<h3 id="goroutine_2">启动多个goroutine<a class="headerlink" href="#goroutine_2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span><span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;sync&quot;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">func</span> <span class="nx">hello</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">){</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span> <span class="c1">//通知wg计数器减1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//wg计数器加1</span>
        <span class="k">go</span> <span class="nx">hello</span><span class="p">()</span><span class="c1">// 启动另外一个goroutine去执行hello函数</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;main done&quot;</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span> <span class="c1">//阻塞,等待其他计数器归零</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="_3">可增长的栈<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>OS线程(操作系统的线程)一般固定栈内存通常为2MB,而一个goroutine的栈在其生命周期开始时只有很小的栈(1.5以后2kb),goroutine的栈不是固定的,可以按需增加和减小,最大限制可以到达1GB,所以理论上一次可以创建十万次左右的goroutine.</p>
<h3 id="goroutine_3">goroutine调度<a class="headerlink" href="#goroutine_3" title="Permanent link">&para;</a></h3>
<p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h3 id="gomaxprocs">GOMAXPROCS<a class="headerlink" href="#gomaxprocs" title="Permanent link">&para;</a></h3>
<p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;A:&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;B:&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">a</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">b</span><span class="p">()</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。</span>
<span class="c1">//将逻辑核心数设为2，此时两个任务并行执行，代码如下。</span>
<span class="kd">func</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;A:&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;B:&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOMAXPROCS</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">a</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">b</span><span class="p">()</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ol>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。m个goroutine分配到n个cpu上去执行</li>
</ol>
<h1 id="channel">channel<a class="headerlink" href="#channel" title="Permanent link">&para;</a></h1>
<ol>
<li>channel是一种引用类型</li>
<li>channel本质是一个数据结构的队列.</li>
<li>channel是先进先出FIFO,first in first out</li>
<li>线程安全,多goroutine访问时,不需要加锁,channel本身是线程安全的</li>
<li>channel是有类型的,一个string的channel只能放string类型的数据</li>
</ol>
<h3 id="_4">声明<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p><code>var 变量 chan 元素类型</code></p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">intChan</span> <span class="kd">chan</span> <span class="kt">int</span> <span class="p">(</span><span class="nx">intChan用于存放int数据</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">mapChan</span> <span class="kd">chan</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>   
<span class="kd">var</span> <span class="nx">perChan</span> <span class="kd">chan</span> <span class="nx">Person</span>
<span class="kd">var</span> <span class="nx">perChan2</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Persion</span>
</code></pre></div>

<h6 id="_5">说明<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h6>
<ol>
<li>channel是引用类型</li>
<li>channel必须初始化才能写入数据,即使用前需要先make</li>
<li>管道是有类型的,intChan只能写入整数int</li>
</ol>
<h3 id="_6">初始化<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>通道是引用类型,即其空值为nil</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &lt;nil&gt;</span>
</code></pre></div>

<p>声明通道后,使用之前需要make初始化后才能使用.</p>
<div class="codehilite"><pre><span></span><code><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">元素类型</span><span class="p">,[</span><span class="nx">缓冲大小</span><span class="p">])</span>
<span class="nx">ch4</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="nx">ch5</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
<span class="nx">ch6</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>
</code></pre></div>

<p>channel的缓冲大小可以选择写或不写.</p>
<h3 id="_7">操作<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用<code>&lt;-</code>符号。</p>
<p>定义一个通道</p>
<div class="codehilite"><pre><span></span><code><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></div>

<h5 id="_8">发送<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h5>
<p>将一个值发送到通道中。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span> <span class="c1">// 把10发送到ch中</span>
</code></pre></div>

<h5 id="_9">接收<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h5>
<p>从一个通道中接收值。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span> <span class="c1">// 从ch中接收值并赋值给变量x</span>
<span class="o">&lt;-</span><span class="nx">ch</span>       <span class="c1">// 从ch中接收值，忽略结果</span>
</code></pre></div>

<h5 id="_10">关闭<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h5>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<div class="codehilite"><pre><span></span><code><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</code></pre></div>

<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ol>
<p>使用内置函数close可以关闭channel,当channel关闭后,就不能再向channel写数据了,但是依然可以从该channel读取数据.</p>
<p>类似于添加了写锁,而读没有限制.</p>
<p>close为内置函数,效果是再最后发送的值被接收后停止该通道.</p>
<h5 id="_11">注意:<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h5>
<ol>
<li>channel中只能存放指定数据类型,如果要使用多种数据结构,需要使用空接口</li>
<li>channel数据放满cap后不可以继续存入,报deadlock错</li>
<li>如果channel中数据为空,继续取值,报deadlock错</li>
</ol>
<h3 id="_12">无缓冲的通道<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;发送成功&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<div class="codehilite"><pre><span></span><code>fatal error: all goroutines are asleep - deadlock!

goroutine <span class="m">1</span> <span class="o">[</span>chan send<span class="o">]</span>:
main.main<span class="o">()</span>
        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54
</code></pre></div>

<p>为什么会出现<code>deadlock</code>错误呢？</p>
<p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">recv</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ret</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;接收成功&quot;</span><span class="p">,</span> <span class="nx">ret</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">recv</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// 启用goroutine从通道接收值</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;发送成功&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h5 id="_13">注意<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h5>
<p>无缓冲的管道默认len和cap都是0</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span>  <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
<span class="p">}</span>
<span class="o">&gt;&gt;</span><span class="p">&gt;</span>
<span class="mi">0</span>
<span class="mi">0</span>
</code></pre></div>

<h3 id="_14">有缓冲的管道<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 创建一个容量为1的有缓冲区通道</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;发送成功&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>
<h3 id="channel_1">接收空接口的channel<a class="headerlink" href="#channel_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span>
    <span class="nx">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//定义一个可以存放任意数据类型的管道</span>
    <span class="c1">//var allChan chan interface{}</span>
    <span class="nx">allChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span> <span class="mi">3</span><span class="p">)</span>

    <span class="nx">allChan</span> <span class="o">&lt;-</span> <span class="mi">10</span>
    <span class="nx">allChan</span> <span class="o">&lt;-</span> <span class="s">&quot;agsol&quot;</span>
    <span class="nx">cat</span> <span class="o">:=</span> <span class="nx">Cat</span><span class="p">{</span><span class="s">&quot;tom&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
    <span class="nx">allChan</span> <span class="o">&lt;-</span> <span class="nx">cat</span>

    <span class="c1">//如果希望得到channel中第三个数据,需要将其前面的两个数据先推出</span>
    <span class="c1">//channel的推出可以没有变量接收</span>
    <span class="o">&lt;-</span><span class="nx">allChan</span>
    <span class="o">&lt;-</span><span class="nx">allChan</span>

    <span class="nx">newCat</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">allChan</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;newCat = %T,newCat=%v\n&quot;</span><span class="p">,</span> <span class="nx">newCat</span><span class="p">,</span> <span class="nx">newCat</span><span class="p">)</span>
    <span class="c1">// fmt.Printf(&quot;newCat.Name %v&quot;, newCat.Name)</span>
    <span class="c1">//上面的输出类型为接口,无法进行操作,需要进行类型断言,编译无法通过</span>
    <span class="c1">//使用类型断言</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nx">newCat</span><span class="p">.(</span><span class="nx">Cat</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;newCat.Name %v&quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">&gt;&gt;</span><span class="p">&gt;</span>
<span class="nx">newCat</span> <span class="p">=</span> <span class="nx">main</span><span class="p">.</span><span class="nx">Cat</span><span class="p">,</span><span class="nx">newCat</span><span class="p">={</span><span class="nx">tom</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">newCat</span><span class="p">.</span><span class="nx">Name</span> <span class="nx">tom</span>
</code></pre></div>

<p>注意:newCat在从管道中推出的时候,数据类型为interface{},所以没有Name属性,需要接口取值时要使用类型断言.</p>
<h3 id="channel_2">channel的遍历<a class="headerlink" href="#channel_2" title="Permanent link">&para;</a></h3>
<p>channel支持for-range的方式进行遍历.</p>
<p>在遍历过程中,如果channel没有关闭,则会报deadlock错误</p>
<p>在遍历过程中,如果channel已经关闭,则会正常遍历数据,遍历完成后,会退出遍历.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">intChan2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">intChan2</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="p">}</span>
    <span class="c1">//在遍历前关闭管道</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">intChan2</span><span class="p">)</span>
    <span class="c1">//遍历</span>
    <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">intChan2</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;v=&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<ol>
<li>遍历管道时不能使用普通的for循环,因为管道内数据个数变化,所以len无法精确取值</li>
<li>遍历前要关闭管道,否则在遍历到头之后,还会继续遍历,导致报错<code>fatal error: all goroutines are asleep - deadlock!</code>,此种做法虽然最后报错,但是结果会被遍历出来.</li>
<li>使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</li>
</ol>
<h3 id="_15">单向通道<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<p>在函数的参数中设置是否为单向通道.</p>
<p>Go语言中提供了**单向通道**来处理这种情况。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">//单向进入管道</span>
<span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//单项出管道</span>
<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>其中，</p>
<ul>
<li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li>
<li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li>
</ul>
<p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>
<h3 id="channel_3">channel的阻塞机制<a class="headerlink" href="#channel_3" title="Permanent link">&para;</a></h3>
<p>满了或者没了就会阻塞.</p>
<h3 id="_16">通道异常总结<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<p>关闭已经关闭的channel会引发panic</p>
<p><img alt="" src="D:\learning\笔记\图片\Go\channel异常总结.png" /></p>
<h3 id="_17">异常捕获<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<p>当开启多个协程时,不希望某一个协程出现问题导致整体代码的panic.</p>
<p>可以使用defer+recover来解决</p>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//使用defer+recover解决</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//捕获异常</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;test error&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="kd">var</span> <span class="nx">myMap</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>
    <span class="nx">myMap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;golang&quot;</span> <span class="c1">//因为没有make,所以会报错</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">sayHello</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">test</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;main ok&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>defer 内建函数,所在方法里退出时调用，一个方法里若有多个defer语句，则先声明的后被调用，一般与recover()函数一起配合使用，recover()一般用于捕捉panic抛出的异常</p>
<h1 id="worker-poolgoroutine">worker pool(goroutine池)<a class="headerlink" href="#worker-poolgoroutine" title="Permanent link">&para;</a></h1>
<p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">worker</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">jobs</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">results</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">jobs</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;worker:%d start job:%d\n&quot;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;worker:%d end job:%d\n&quot;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
        <span class="nx">results</span> <span class="o">&lt;-</span> <span class="nx">j</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">jobs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="nx">results</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="c1">// 开启3个goroutine</span>
    <span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">w</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">worker</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">jobs</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 5个任务</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">jobs</span> <span class="o">&lt;-</span> <span class="nx">j</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">jobs</span><span class="p">)</span>
    <span class="c1">// 输出结果</span>
    <span class="k">for</span> <span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">a</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">a</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="nx">results</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="select">select多路复用<a class="headerlink" href="#select" title="Permanent link">&para;</a></h3>
<p>在某些场景下我们需要同时从多个通道接收数据。</p>
<p>Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p>
<p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>
<div class="codehilite"><pre><span></span><code><span class="k">select</span><span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
        <span class="o">...</span>
    <span class="k">case</span> <span class="nx">data</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
        <span class="o">...</span>
    <span class="k">case</span> <span class="nx">ch3</span><span class="o">&lt;-</span><span class="nx">data</span><span class="p">:</span>
        <span class="o">...</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nx">默认操作</span>
<span class="p">}</span>
</code></pre></div>

<p>举个小例子来演示下<code>select</code>的使用：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span><span class="p">:</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>使用<code>select</code>语句能提高代码的可读性。</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作。</li>
<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>
<li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li>
</ul>
<h1 id="_18">并发安全和锁<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="c1">//编写一额函数,计算1到200各个数的阶乘,并放入map种</span>
<span class="c1">//启动多个协程,将统计的结果放到map,此map应该是一个全局的</span>
<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">myMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">//计算n的阶乘,将结果放入map中</span>
<span class="kd">func</span> <span class="nx">test</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">res</span> <span class="o">*=</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="c1">//将res结果放入myMap中</span>
    <span class="nx">myMap</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>  
    <span class="c1">//会触发fatal error: concurrent map writes错误</span>
    <span class="c1">//触发了写保护</span>

<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//开启多个协程完成任务</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">200</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">test</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
    <span class="c1">//输出map结果</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">myMap</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;map[%d]=%d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//go build -race main.go  当出现资源竞争的时候,race会将信息打印出来</span>
<span class="c1">//会报Found 3 data race(s),表示三个资源竞争</span>
</code></pre></div>

<h3 id="_19">互斥锁<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">x</span> <span class="kt">int64</span>
<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">var</span> <span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

<span class="kd">func</span> <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">lock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span> <span class="c1">// 加锁</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nx">lock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span> <span class="c1">// 解锁</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">add</span><span class="p">()</span>
    <span class="k">go</span> <span class="nx">add</span><span class="p">()</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>
<h3 id="_20">读写互斥锁<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<p>读写锁示例：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">x</span>      <span class="kt">int64</span>
    <span class="nx">wg</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">lock</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">rwlock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">write</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// lock.Lock()   // 加互斥锁</span>
    <span class="nx">rwlock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span> <span class="c1">// 加写锁</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span> <span class="c1">// 假设读操作耗时10毫秒</span>
    <span class="nx">rwlock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>                   <span class="c1">// 解写锁</span>
    <span class="c1">// lock.Unlock()                     // 解互斥锁</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">read</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// lock.Lock()                  // 加互斥锁</span>
    <span class="nx">rwlock</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span>               <span class="c1">// 加读锁</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span> <span class="c1">// 假设读操作耗时1毫秒</span>
    <span class="nx">rwlock</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>             <span class="c1">// 解读锁</span>
    <span class="c1">// lock.Unlock()                // 解互斥锁</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nx">write</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="nx">read</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nx">end</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">Sub</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>

<p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
<h3 id="syncwaitgroup">sync.WaitGroup<a class="headerlink" href="#syncwaitgroup" title="Permanent link">&para;</a></h3>
<p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">(wg * WaitGroup) Add(delta int)</td>
<td align="center">计数器+delta</td>
</tr>
<tr>
<td align="center">(wg *WaitGroup) Done()</td>
<td align="center">计数器-1</td>
</tr>
<tr>
<td align="center">(wg *WaitGroup) Wait()</td>
<td align="center">阻塞直到计数器变为0</td>
</tr>
</tbody>
</table>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello Goroutine!&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">hello</span><span class="p">()</span> <span class="c1">// 启动另外一个goroutine去执行hello函数</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;main goroutine done!&quot;</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

<p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>
<h4 id="_21">并发安全的单例模式<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">singleton</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;sync&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>
<span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>

<span class="kd">func</span> <span class="nx">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
    <span class="nx">once</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">instance</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">singleton</span><span class="p">{}</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">instance</span>
<span class="p">}</span>
</code></pre></div>

<p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h3 id="syncmap">sync.Map<a class="headerlink" href="#syncmap" title="Permanent link">&para;</a></h3>
<p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">key</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
            <span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;k=:%v,v:=%v\n&quot;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

<p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">key</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
            <span class="nx">m</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
            <span class="nx">value</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Load</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;k=:%v,v:=%v\n&quot;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
        <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

<h1 id="_22">原子操作<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h1>
<p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h3 id="atomic">atomic包<a class="headerlink" href="#atomic" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td>
<td align="center">读取操作</td>
</tr>
<tr>
<td align="center">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td>
<td align="center">写入操作</td>
</tr>
<tr>
<td align="center">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td>
<td align="center">修改操作</td>
</tr>
<tr>
<td align="center">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td align="center">交换操作</td>
</tr>
<tr>
<td align="center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td>
<td align="center">比较并交换操作</td>
</tr>
</tbody>
</table>
<h5 id="_23">示例<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h5>
<p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;sync&quot;</span>
    <span class="s">&quot;sync/atomic&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Inc</span><span class="p">()</span>
    <span class="nx">Load</span><span class="p">()</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="c1">// 普通版</span>
<span class="kd">type</span> <span class="nx">CommonCounter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">counter</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">CommonCounter</span><span class="p">)</span> <span class="nx">Inc</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">counter</span><span class="o">++</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">CommonCounter</span><span class="p">)</span> <span class="nx">Load</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">counter</span>
<span class="p">}</span>

<span class="c1">// 互斥锁版</span>
<span class="kd">type</span> <span class="nx">MutexCounter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">counter</span> <span class="kt">int64</span>
    <span class="nx">lock</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MutexCounter</span><span class="p">)</span> <span class="nx">Inc</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">counter</span><span class="o">++</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MutexCounter</span><span class="p">)</span> <span class="nx">Load</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">counter</span>
<span class="p">}</span>

<span class="c1">// 原子操作版</span>
<span class="kd">type</span> <span class="nx">AtomicCounter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">counter</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AtomicCounter</span><span class="p">)</span> <span class="nx">Inc</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nx">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">.</span><span class="nx">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AtomicCounter</span><span class="p">)</span> <span class="nx">Load</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">.</span><span class="nx">counter</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">test</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Counter</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">c</span><span class="p">.</span><span class="nx">Inc</span><span class="p">()</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
        <span class="p">}()</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nx">end</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Load</span><span class="p">(),</span> <span class="nx">end</span><span class="p">.</span><span class="nx">Sub</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c1</span> <span class="o">:=</span> <span class="nx">CommonCounter</span><span class="p">{}</span> <span class="c1">// 非并发安全</span>
    <span class="nx">test</span><span class="p">(</span><span class="nx">c1</span><span class="p">)</span>
    <span class="nx">c2</span> <span class="o">:=</span> <span class="nx">MutexCounter</span><span class="p">{}</span> <span class="c1">// 使用互斥锁实现并发安全</span>
    <span class="nx">test</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c2</span><span class="p">)</span>
    <span class="nx">c3</span> <span class="o">:=</span> <span class="nx">AtomicCounter</span><span class="p">{}</span> <span class="c1">// 并发安全且比互斥锁效率更高</span>
    <span class="nx">test</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2019 - 2020 Agsol
          </div>
        
        powered by
        <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c33a9706.js"></script>
      
      <script>app.initialize({version:"1.1",url:{base:"../.."}})</script>
      
        <script src="../../javascripts/extra.js"></script>
      
    
  </body>
</html>